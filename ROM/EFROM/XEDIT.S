			;Internal routines
	GLOBAL GETCR0
	GLOBAL INLINE
	GLOBAL HOLD
	GLOBAL SETFRM
	GLOBAL EDITA
	GLOBAL EDITCH
	GLOBAL GETCUR
	GLOBAL BACAL
	GLOBAL ADHLA
	GLOBAL CPDB
	GLOBAL CURRT
	GLOBAL WAIT
			;External routines
	GLOBAL SHOCUR
	GLOBAL REMCUR
	GLOBAL EDOUT
	GLOBAL EDOUT1
	GLOBAL WRNC
	GLOBAL RDKEY
	GLOBAL FICLKL
			;External locations
	GLOBAL TVRAM
 
FF	EQU 0CH		;Characters, codes & parameters
PR	EQU 03H
LF	EQU 0AH		
CR	EQU 0DH		
VT	EQU 0BH
BS	EQU 08H
SCR	EQU 10H
HT	EQU 1AH
CHL	EQU 01CH
CLL	EQU 01EH
IL	EQU 01H
DL	EQU 02H
MP	EQU 012H
MS	EQU 013H
XY	EQU 16H
BLANK	EQU 20H		
CLEAR	EQU 1FH		
UNCHR	EQU 68H		
CONCHR	EQU 127
 
			;Restart routine
ZGETCUR	EQU 0CFH
 
FL1	EQU 25		;video frame length
FL2	EQU 30		;ditto for "PET mode"
UCR	EQU 3		;control bit for the above
TVMMSK	EQU 0BH		;so only bits 3,1,0 of TVMODE
			;can be changed by ctl/W
	EJECT
UNUSED	EQU 0
TVMD1	EQU 1
TVMD2	EQU 2
TVMD3	EQU 3
DEP	EQU 4
LL	EQU 5
EL	EQU 6
FLAGS	EQU 7
EXFLGS	EQU 8
LN	EQU 9
FRM	EQU 10
WIN	EQU 11
INPB	EQU 12
INPC	EQU 13
CHAR	EQU 14
DCHR	EQU 15
CSTO	EQU 16
BSTO	EQU 17
ESTO	EQU 18
DSTP	EQU 19
FLGSTO	EQU 20
 
DEPTH	EQU 24
TVLEN	EQU 40
LILEN	EQU 80
ENREG	EQU 7
TVREG	EQU 12		;4 for Bee
TVON	EQU 65
 
SNDXYFLG	EQU 6	;IX EXFLGS
SNDYFLG		EQU 5
SNDCCFLG	EQU 7
CURSHOFLG	EQU 4
 
SFTFLG	EQU 7		;IX FLAGS
IFLG	EQU 6
CNSFLG	EQU 5
CSIFLG	EQU 4	;REDUNDANT!
XYFLG	EQU 3
YFLG	EQU 2
ESCFLG	EQU 1
TVMFLG	EQU 0
 
			;HL FLAGS
TVFLG	EQU 7
OLFLG	EQU 3
LIFLG	EQU 5		;STLIN = BUFFER + 11
CRFLG	EQU 0		;(STLIN)+4 has FLAGS
PGEFLG	EQU 2		;(STLIN)+1 has WINDOW POS. (B)
INPFLG	EQU 4		;(STLIN)+0 has CURSOR POS. (C)
CHRFLG	EQU 6		;(STLIN)+3 has MAX LINE LEN. (D)
HLDFLG	EQU 1		;(STLIN)+2 has CHAR. COUNT (E)
WLEN	EQU 16		;(STLIN)+5 & on is LINE RAM
	EJECT
CODES		;not used by LIIO or in hold mode
	DEFB IL
	DEFB DL
	DEFB MP
	DEFB MS
 
EDADD	DEFW NULL
	DEFW INSLIN
	DEFW DELLIN
	DEFW PGERET
	DEFW NULL
	DEFW LNERET
	DEFW SHOWC
	DEFW HIDEC
	DEFW CURLT
	DEFW DOTAB
	DEFW PLNFD
	DEFW CURUP
	DEFW HOME
	DEFW NLINE
	DEFW SHFTIN
	DEFW SHFTOU
	DEFW NULL
	DEFW INSMOD
	DEFW MKPRM
	DEFW MKSEC
	DEFW CCRET
	DEFW XYRET
	DEFW XYRQST
	DEFW TVRQST
	DEFW DELLT
	DEFW DEL
	DEFW CURRT
	DEFW ESCAPE
	DEFW HOMEL
	DEFW HOMER
	DEFW DLINE
	DEFW CLRSCR
	EJECT
EDITA	LD (IX+CHAR) A
EDITCH	INC HL
	LD A (HL)
	CP CONCHR
	JR NZ EDIT1
	LD (HL) BLANK
EDIT1	DEC HL
	LD A (IX+CHAR)
	CALL PREDIT	;Goes to 'real edit' here
	CALL DOFRM
	PUSH HL
	CALL DELZER
	PUSH BC		;BC = cur. pos. HL > line end
	CALL CPDB	;Is line length >= cursor pos.?
	JR NC DZ2
	LD A E		;No - so use cursor for zero
DZ2	CP (IX+LL)	;Is line 'full'
	JR Z DZ3
	CALL ADHLA	;No - so put in zero
	LD (HL) 0
DZ3	POP BC
	POP HL
	RET
 
DELZER			;Going to search for last
	PUSH BC		;zero in functional line
	LD B D
	LD C 0
	DEFB ZGETCUR	;HL > line start
	PUSH HL
	LD A (IX+LL)
	SUB E
	JR Z DZ1	;If line full
	LD C A
	ADD A E
	DEC A
	CALL ADHLA	;HL > line end
	XOR A
	LD B A
	CPDR
	JR NZ DZ1
	INC HL
	LD (HL) BLANK
DZ1	POP HL		;HL > line start
	POP BC
	RET
 
PREDIT	CALL EDIT
	RES CRFLG (HL)
	RET
 
	EJECT
TVMSET	RES TVMFLG (IX+FLAGS)
	AND TVMMSK		;Mask out top two bits
	LD (IX+CHAR),A
	LD A,(IX+TVMD1)
	AND .NOT.TVMMSK
	OR (IX+CHAR)
	LD (IX+TVMD1) A
	RET
 
SETXY	BIT YFLG (IX+FLAGS)
	JR NZ SECOND
	SET YFLG (IX+FLAGS)
	PUSH AF
	CALL HOME
	POP AF
	OR A
	RET Z
	DEC A
	CP (IX+LL)
	JR C AOK
	LD A (IX+LL)
AOK	LD C A
	OR A
	RET NZ
	LD A B
	OR A
	RET Z
	INC C
	RET
 
SECOND	RES XYFLG (IX+FLAGS)
	RES YFLG (IX+FLAGS)
	OR A
	RET Z
TESTA	DEC (IX+CHAR)
	RET Z
	CALL LNFD
	JR TESTA
 
	EJECT
EDIT	BIT XYFLG (IX+FLAGS)
	JR NZ SETXY
	BIT TVMFLG (IX+FLAGS)
	JR NZ TVMSET
	BIT ESCFLG (IX+FLAGS)
	RES ESCFLG (IX+FLAGS)
	JR NZ INSERT
EDIT2	CP 20H
	JR NC INSERT
	RES IFLG (IX+FLAGS)
	PUSH HL
	PUSH BC
	BIT HLDFLG (HL)
	JR NZ DECODE
	CP CLEAR
	JR Z NOTONE
	BIT OLFLG (HL)
	JR Z NOTONE
DECODE	CP CLEAR
	JR NZ NOTCLR
	LD A CLL
NOTCLR	CP FF
	JR NZ NDC
	LD A CHL
NDC	LD HL CODES
	LD BC EDADD-CODES
	CPIR
	JR NZ NOTONE
	XOR A
NOTONE	LD (IX+CHAR) A
	LD HL EDADD
	ADD A A
	CALL ADHLA
	LD C (HL)
	INC HL
	LD H (HL)
	LD L C
	POP BC
	EX (SP) HL
	RET
 
INSERT	LD A 80H
	AND (IX+FLAGS)
	XOR (IX+CHAR)
	LD (IX+CHAR) A
	RET Z
	CALL TSINP
	RET C
	BIT IFLG (IX+FLAGS)	
	JR NZ INSNOW-$	
	BIT CRFLG (HL)	
	CALL NZ DLINE
	EJECT
PUT	CALL CPDB
	JR C PUT2
	LD E C
PUT1	CALL INCDE
PUT2	CALL CURRT
	CALL CURLT
	PUSH HL
	DEFB ZGETCUR
	LD A (IX+CHAR)
	LD (HL) A
	POP HL
	JR CURRT
 
MKSEC	XOR A
	CP B
	RET NZ
	CP (IX+LN)
	RET Z
	PUSH DE
	CALL SCHUP
	CALL CNTCH
	PUSH HL
	CALL DELZER
	POP HL
	LD A D
	POP DE
	INC A
	PUSH AF
	ADD A D
	LD D A
	POP AF
	ADD A B
	LD B A
	LD C 0
	LD (IX+CHAR) CONCHR
 
INSNOW	CALL CPDB
	JR C INSN1
	LD E C
INSN1	CALL INCDE
	PUSH BC
	LD A D
	SUB B
	JR Z INSN3
	PUSH DE
	LD E (IX+LL)
	LD D A
INSN2	CALL ICIL
	LD C 1
	INC B
	DEC D
	JR NZ INSN2
	POP DE
INSN3	CALL ICIL
	POP BC
	EJECT
CURRT	LD A (IX+LL)
	DEC A
	SUB C
	JR C CURRT1
	INC BC
	RET NZ
CURRT1	LD (IX+DCHR) A
	LD A B
	CP D
	RET NC
	INC B
	XOR A
	LD (IX+WIN) A
	INC A
	SUB (IX+DCHR)
	LD C A
	RET
 
PWAIT	CALL ADJWIN
WAIT	CALL WRNC
	CALL RDKEY
	SUB CR
	JR NZ PWAIT
	JR HOMEL-$
 
CURLT	BIT LIFLG (HL)
	JR NZ CURLT2
	CALL TSINP
	RET Z
CURLT2	LD A C
	OR A
	RET Z
	DEC C
	RET NZ
	LD A B
	CP 1
	RET C
	LD C (IX+LL)
	DEC B
	DEC C
	RET
 
ADJWIN	LD C (IX+WIN)
	CP BS-CR	;
	JR Z CURLT	;
	CP FF-CR	;
	JR Z HOMEL-$	;
	CP HT-CR	;
	RET NZ		;
 
WINRT	LD A (IX+WIN)
	ADD A WLEN-1
	LD C A
	JR CURRT
	EJECT
PGERET	BIT HLDFLG (HL)
	RET NZ
	SET PGEFLG (HL)
	XOR A
	CALL LNFD2
LNERET	RES CRFLG (HL)
NLINE	POP AF
INLINE	XOR A		;used by XIO input
	BIT CRFLG (HL)
	SET CRFLG (HL)
	SET CHRFLG (HL)
	RES HLDFLG (HL)
	JR Z NLINE1
	BIT INPFLG (HL)
	JR Z DLINE
	LD (IX+INPB) D
	LD (IX+INPC) E
NLINE1	LD B A
	LD C A
	RET
 
DLINE	CALL HOLD
DLINE1	LD A D
	CP B
	JR Z DLINE2
	ADD A (IX+LN)
	CALL SCROLL
	DEC D
	JR DLINE1
DLINE2	ADD A (IX+LN)
	CALL WLIN
	LD E C
 
HOMEL	XOR A
	LD B A
	LD C A
HOMEL1	BIT LIFLG (HL)
	RET NZ
HOLD	LD B (IX+INPB)
	LD C (IX+INPC)
	RET
 
	EJECT
CLRSCR	XOR A
	LD C A
CS1	CALL WLIN
	INC A
	CP (IX+DEP)
	JR NZ CS1
 
HOME	CALL ZERO
	JP LNFD2
 
HOMER	LD C (IX+LL)
	LD B D
	RET
 
 
PLNFD	BIT CHRFLG (HL)
	RES CHRFLG (HL)
	JR NZ PLNFD1
LNFD	LD A D
	CP B
	JR Z LNFD1
	INC B
	LD A 1
	CP B
	RET NZ
	XOR A
	CP C
	RET NZ
	INC C
	RET
	EJECT
PLNFD1	POP AF
	LD A D
LNFD1	BIT HLDFLG (HL)
	RET NZ
	ADD A (IX+LN)
	INC A
	CP (IX+DEP)
	JR NZ LNFD2
	DEC A
	BIT INPFLG (HL)
	RET NZ
	BIT CRFLG (HL)
	RET Z
	BIT PGEFLG (HL)
	JR NZ HOME
	LD (IX+LN) A
	CALL ZERO
	JP SCROLL
 
LNFD2	LD (IX+LN) A
LNFD4	XOR A
	CP B
	LD B A
	PUSH AF
	PUSH BC
	LD C B
	LD D B
LNFD3	INC B
	PUSH HL
	DEFB ZGETCUR
	POP HL
	CP CONCHR
	JR Z LNFD3
	LD D B
	DEC D
	POP BC
	POP AF
	JR Z CNTCH
	INC A
	CP C
	JR NZ CNTCH
	DEC C
	EJECT
CNTCH	PUSH HL
	PUSH BC
	LD B D
	LD E (IX+LL)
	LD C E
	DEC C
	DEFB ZGETCUR
CNTCH1	LD A 0DFH
	AND (HL)
	JR NZ CNTCH2
	DEC HL
	DEC E
	JR Z CNTCH2
	LD A 2
	CP E
	JR NZ CNTCH1
	LD A D
	OR A
	JR Z CNTCH1
CNTCH2	POP BC
	POP HL
	RET
 
CURUP	XOR A
	CP B
	JR Z CURUP1
	DEC B
	CALL TSINP
	JP C HOMEL1
	RET Z
	LD A B
	OR A
	RET NZ
	DEC C
	RET Z
	INC C
	RET
CURUP1	BIT HLDFLG (HL)
	RET NZ
	CP (IX+LN)
	RET Z
CURUP2	CALL SCHUP
	XOR A
	LD B D
	CP B
	JR Z CNTCH
	CP C
	JR NZ CNTCH
	INC C
	JR CNTCH
	EJECT
MKPRM	LD A B
	OR A
	RET Z
	ADD A (IX+LN)
	LD (IX+LN) A
	LD A D
	SUB B
	LD D A
	LD B 0
	LD C 1
 
DELLT	CALL TSINP
	RET Z
	RET C
	CALL CHKFRM
	BIT TVFLG (HL)
	JR NZ DELLT1
	LD A C
	CP (IX+WIN)
	RET Z
DELLT1	CALL CURLT
DEL	CALL TSINP
	RET C
	CALL CPDB
	RET NC
	LD (IX+DCHR) BLANK
	PUSH DE
	LD A D
	SUB B
	JR Z DELL2
	PUSH BC
	LD C 1
	LD B D
	LD D A
DELL1	CALL DCFL
	LD E (IX+LL)
	DEC B
	DEC D
	JR NZ DELL1
	POP BC
DELL2	CALL DCFL
	POP DE
	DEC E
	LD A E
	CP 1
	RET NZ
	LD A D
	CP 1
	RET C
	LD E (IX+LL)
	DEC D
	CP B
	JR NZ DELL5
	LD C E
	LD B D
DELL5	ADD A (IX+LN)
	EJECT
SCROLL	PUSH HL
	PUSH DE
	PUSH BC
	PUSH AF
	PUSH HL
SCRLL1	CALL ADLIN
	SUB (IX+DEP)
	CPL
	CALL CALIN
	JR Z SCRLL3
	CALL GETDE
*Now do LDIR except that when moving into a
*position immediately above which is a zero
*that zero is first changed to a space.
	DEC BC
SCRLLA	INC DE
	LD A,(DE)
	OR A
	JR NZ SCRLLB
	LD A,BLANK
	LD (DE),A
SCRLLB	DEC DE
	LDI
	JP PE SCRLLA
	INC BC
	LDI
*Now the psedo ldir is complete
SCRLL3	LD A (IX+DEP)
	DEC A
	POP HL
SCRLL4	CALL WLIN
	POP AF
	POP BC
	POP DE
	POP HL
	RET
 
INSLIN	CALL ZERO
	LD A (IX+LN)
 
ILIN	PUSH HL
	PUSH DE
	PUSH BC
	PUSH AF
	PUSH HL
	LD D (IX+DEP)
	SUB D
	NEG
	JR NZ ILIN1
	DEC (IX+LN)
	JR SCRLL1
ILIN1	DEC A
	CALL CALIN
	JR Z ILIN2
	LD A D
	DEC A
	CALL ADLIN1
	CALL GETDE
	EX DE HL
	LDDR
ILIN2	POP HL
	POP AF
	PUSH AF
	JR SCRLL4
	EJECT
DELLIN	LD B D
	INC B
	LD A (IX+LN)
DELLN1	CALL SCROLL
	DJNZ DELLN1
	CALL ZERO
	JP LNFD4
 
DOTAB	LD A C
	AND 7
	SUB 8
	NEG
DT1	PUSH AF
	CALL CURRT
	POP AF
	DEC A
	JR NZ DT1
	RET
 
SHOWC	SET CURSHOFLG (IX+EXFLGS)
	RET
 
HIDEC	RES CURSHOFLG (IX+EXFLGS)
	RET
 
INSMOD	SET IFLG (IX+FLAGS)	;
	RET		;
 
ESCAPE	SET ESCFLG (IX+FLAGS)
	RET
 
SHFTIN	SET SFTFLG (IX+FLAGS)
	RET
 
SHFTOU	RES SFTFLG (IX+FLAGS)
NULL	RET
 
ADHLA	ADD A L		;
	LD L A		;
	RET NC		;
	INC H		;
	RET		;
 
TSINP	LD A B
	CP (IX+INPB)
	RET NZ
	LD A C
	CP (IX+INPC)
	RET
 
ZERO	XOR A
	LD B A
	LD C A
	LD D A
	LD E A
	RET
	EJECT
GETDE	LD D H
	LD E L
	LD A 1
	DEC HL
ADLIN	INC HL
ADLIN1	PUSH BC
	CALL CALIN
	ADD HL BC
	POP BC
	RET
 
BACAL	LD C A
	XOR A
	LD B A
CAL1	ADD A C
	JR NC CAL2
	INC B
CAL2	DEC D
	JR NZ CAL1
	LD C A
	RET
 
CALIN	LD BC 0
	OR A
	RET Z
	PUSH DE
	PUSH AF
	LD D A
	LD A (IX+EL)
	CALL BACAL
	POP AF
	POP DE
	RET
 
GETCUR	LD A (IX+LN)
	ADD A B
GETCR0	CALL ADLIN
	LD A C
	CALL ADHLA
	LD A (HL)
	RET
	EJECT
WLIN	PUSH HL
	PUSH BC
	PUSH AF
	CALL GETCR0
	LD A (IX+EL)
	SUB C
	LD B A
	LD (HL) 0
	DEFB 0CCH	;'call z' - flag is nz
WLIN1	LD (HL) BLANK
	INC HL
	DJNZ WLIN1
WLIN2	POP AF
	POP BC
	POP HL
	RET
 
CCRET	BIT INPFLG (HL)
	RET NZ
	SET SNDCCFLG (IX+EXFLGS)
	RET
 
XYRET	BIT INPFLG (HL)
	RET NZ
	SET SNDXYFLG (IX+EXFLGS)
	RET
 
XYRQST	BIT HLDFLG (HL)
	RET NZ
	SET XYFLG (IX+FLAGS)
	RET
 
TVRQST	BIT TVFLG (HL)
	RET Z
	SET TVMFLG (IX+FLAGS)
	RET
 
	EJECT
INCDE	LD A E
	CP (IX+LL)
	JR Z INCDE1
	INC E
	RET
 
INCDE1	LD A D
	INC A
	CP (IX+DEP)
	JR NZ NOSTOP
	BIT INPFLG (HL)
	JR Z STPTS1
	POP AF
	RET
 
STPTS1	BIT OLFLG (HL)
	JR Z STPTS2
	POP AF
	LD A (IX+CHAR)
	PUSH AF
	LD A CR
	CALL EDOUT
	SET ESCFLG (IX+FLAGS)
	POP AF
	JP EDOUT1
	EJECT
STPTS2	INC (IX+LN)
	DEC D
	DEC B
	DEC A
NOSTOP	INC D
	ADD A (IX+LN)
	CALL ILIN
	PUSH HL
	LD A D
	ADD A (IX+LN)
	CALL ADLIN
	LD (HL) CONCHR
	POP HL
	LD E 2
	RET
 
SCHUP	PUSH BC
	LD BC 0
	LD D B
SCHUP3	DEC (IX+LN)
	PUSH HL
	DEFB ZGETCUR
	POP HL
	CP CONCHR
	JR NZ SCHUP4
	INC D
	JR SCHUP3
SCHUP4	POP BC
	RET
 
ICIL	LD A E
	SUB C
	RET Z
	RET C
	PUSH HL
	PUSH BC
	PUSH AF
	DEFB ZGETCUR
	POP BC
	LD C (IX+CHAR)
ICIL1	LD A (HL)
	LD (HL) C
	LD C A
	INC HL
	DJNZ ICIL1
	LD (IX+CHAR) C
	POP BC
	POP HL
	RET
	EJECT
DCFL	LD A E
	SUB C
	RET Z
	RET C
	PUSH HL
	PUSH BC
	PUSH AF
	LD C E
	DEFB ZGETCUR
	POP BC
	LD C (IX+DCHR)
DCFL1	DEC HL
	LD A (HL)
	LD (HL) C
	LD C A
	DJNZ DCFL1
	LD (IX+DCHR) C
	POP BC
	POP HL
	RET
 
CPDB	LD A B
	CP D
	RET NZ
	LD A C
	CP E
	RET
 
	EJECT
DOFRM:		;Preserves BCDEHL
		;CASE cursor line < FRM
		;  A:= FRM:= cur line CY set
		;CASE FRM<=cur line<=FRM+23
		;  A:=FRM+23 CY clear
		;  Z set iff cur line=FRM+23
		;CASE FRM+23<cur line
		;  A:= FRM:= cur line-23 CY clear
		;Z set iff cur. line=23
	;ALTERED SO TWO POSS. FRAME LENS 23 AND 29
	PUSH BC
	LD A,(IX+LN)
	ADD A,B		;so A= cur line
	LD B,(IX+FRM)
	CP B
	JR C DF4	;if cur lin<FRM
	LD C,A		;so C= cur line
	LD A,B		;so A= FRM
	LD B,FL1-1	;B= frame length
	BIT UCR,(IX+TVMD1)
	JR Z DF1	;if not "PET display"
	LD B,FL2-1
DF1:	ADD A,B		;so A= last displayed line
	CP C
	LD A,C		;so A= cur line
	JR NC DF5	;if last disp line>=cur line
	SUB B		;so A= cur line - frame len
DF4:	LD (IX+FRM),A
DF5:	POP BC
	RET
 
	EJECT
SETFRM	LD HL (TVRAM)
	PUSH HL
	POP IX
	LD B (HL)
	INC HL
	LD A (FICLKL)
	BIT 4 A
	LD A (HL)
	JR Z STFM1
	SET 7 A
STFM1	OUT (TVREG) A
	LD A B
	ADD A 4
	CALL ADHLA
	LD A (IX+FRM)
	CALL ADLIN1
	LD B H
	LD C L
	RET
 
CHKFRM	LD A C
	CP 1
	RET NZ
	LD A B
	OR A
	RET Z
	ADD A (IX+LN)
	CP (IX+FRM)
	RET NZ
	POP AF
	RET
 
	END
                                                                                                     