	NAME OS
 
;OPERATING SYSTEM
 
	PSECT ABS
RAM	EQU 0
ENDRAM	EQU 08000H   ;CDESP WAS 0A000H
ROM	EQU 0E000H
EXROM	EQU 0A000H
 
;INTERNALLY DEFINED ROUTINES
 
	GLOBAL CALLHL
	GLOBAL HLTTCAPS
	GLOBAL BUFLG
	GLOBAL TTCAPS
	GLOBAL GETKEY
	GLOBAL IMMKEY
	GLOBAL RDKEY
	GLOBAL RDNSP
	GLOBAL FPID2
	GLOBAL RDIGIT
	GLOBAL BRKTST
	GLOBAL STKTST
	GLOBAL SHLREG
	GLOBAL SPACE
	GLOBAL GSPCBK
	GLOBAL RDINT
	GLOBAL RDBYTE
	GLOBAL NOVID
	GLOBAL SAVIRS
	GLOBAL RESIRS
	GLOBAL IOPON
	GLOBAL IOPOFF
 
	EJECT
;INTERNALLY DEFINED LOCATIONS
 
	GLOBAL TBRP
	GLOBAL RBRP
	GLOBAL FICLKL
	GLOBAL FICLKE
	GLOBAL EXCESS
	GLOBAL TV0
	GLOBAL TV1
	GLOBAL TV2
	GLOBAL TVRAM
	GLOBAL TVCUR
	GLOBAL KBMODE
	GLOBAL PLLEN
	GLOBAL PHPOS
	GLOBAL PZLEN
	GLOBAL COPST
	GLOBAL COPBUF
	GLOBAL COPCTL
	GLOBAL CHKSUM
	GLOBAL OBFEND
	GLOBAL DEVTAB
	GLOBAL UP
	GLOBAL B3PRM
	GLOBAL B4
	GLOBAL DEV0
	GLOBAL DEV2
	GLOBAL CLOCK
	GLOBAL CLACK
	GLOBAL STRTAB
	GLOBAL IOSRAM
	GLOBAL STRTOP
	GLOBAL TRST8
	GLOBAL RST8
	GLOBAL DPSP
	GLOBAL DPSL
	GLOBAL ENREGMAP
	GLOBAL DEFNF
 
	EJECT
;EXTERNALS
 
	GLOBAL ACINIT
	GLOBAL SETFRM
	GLOBAL PADT
	GLOBAL TLIO
	GLOBAL LIIO
	GLOBAL TVIO
	GLOBAL TP1IO
	GLOBAL TP2IO
	GLOBAL NKBWIO
	GLOBAL NKBIIO
	GLOBAL UPIO
	GLOBAL LPIO
	GLOBAL JGIO
	GLOBAL DUMMY
	GLOBAL GRAPH
	GLOBAL ZTABLE
	GLOBAL ZOSTABL
	GLOBAL ZGETKEY
	GLOBAL ZKLOOK
	GLOBAL PCLRTN
	GLOBAL PCLRNC
	GLOBAL POSRTN
	GLOBAL BASIC
	GLOBAL BREADY
	GLOBAL MKSPC
	GLOBAL RETSPC
	GLOBAL POSRNC
	GLOBAL CPID2
	GLOBAL FSTO
 
;ERROR NUMBERS
 
NOROOM	EQU 100	;no room to make buffer
DROPOUTERR	EQU 130		;tape dropout
 
;VIDEO PARAMETERS
 
FLASH1	EQU 0CH		;TV CUR PARS.
FLASH2	EQU 20H
TVOFF	EQU 2		;ALLOWS CLK INT BUT NOT USR INT
UNLIN	EQU 5FH
DOOR	EQU 7FH
SPCE	EQU 20H
 
;COP PARAMETERS
 
COP	EQU 6 	;COP I/O PORT
 
KDATA	EQU 6	;DATA FLAGS SET TO 1 IF UNTRANSMITTED
CDATA	EQU 7	;DATA PRESENT IN BUFFER
READY 	EQU 5	;SET IF COMMAND HAS BEEN TRANSMITTED
BRKKEY	EQU 2
CERR	EQU 4	;CASSETTE ERROR FLAG
BRKOK	EQU 3	;IF RES ALLOWS BREAK
TIMER0	EQU 0
TIMEOUT EQU 4
CBRK	EQU 1	;BREAK KEY BIT
 
UNCHR	EQU 68H	;CODE FOR UREC. CHAR.
 
CASSCOM	EQU 080H  ;COMMANDS
PASSCOM EQU 090H
DISPCOM EQU 0A0H
TIMCOM  EQU 0B0H
PDNCOM  EQU 0C0H
NULLCOM EQU 0D0H
RESCOM  EQU 0F0H
	EJECT
PDNTIM  EQU -4800	;1 min.
 
NKBD	EQU 2	;CONTROL FLAGS
NRGINT  EQU 3
 
	 	;DELAYS IN ORDER TO SYNCHRONISE
CIDEL	EQU 82	;82 FOR 4MH
CODEL	EQU 59	;59 FOR 4MH
KBDEL	EQU 72
SYNCDEL	EQU 80
 
;STATUS REGISTER
 
STREG	EQU 20		;I port 10 for Bee
COPINTBAR	EQU 7		;COP status bit
CLKINTBAR	EQU 5		;Frame Clock status bit
ACINTBAR	EQU 6
UPTINTBAR	EQU 4
POWTEST	EQU 1
EXTEST	EQU 0
 
;ENABLE REGISTER
 
ENREG	EQU 7		;O port
IOPOWER	EQU 3
VIDEO	EQU 2
PTRDMSK	EQU 128		;mask for PRINTER data out
V24DMSK EQU 32		;mask for V24 data out
 
;INT. CONTROL REGISTER
 
INTCON	EQU 4		;O port 9 for Bee
CLRCLK	EQU 1
 
TVLATCH	EQU 8		;pseudo I/O port 5 for Bee
TVLL	EQU 9		;ditto 13 for Bee
 
***MEMORY MAP***
 
	ORG RAM
PARS	DEFS 100H
FPRAM	DEFS 160	;make rm for MAT3CF
STKRAM	DEFS 200
STACK	EQU $
RAMLO	EQU $
	EJECT
	ORG ROM
POWERUP	JP POWERUP+3
	IM 1
	LD A TVOFF+PTRDMSK+V24DMSK
	OUT (ENREG),A
PWAIT	IN A (STREG)
	BIT POWTEST A
	JR NZ PWAIT
	LD DE ENDRAM
	XOR A
RT	LD B A
	CPL
	LD C A
	LD HL RAM
LOOP1	LD (HL) B
	INC HL
	LD (HL) C
	INC HL
	OR A
	SBC HL DE
	JR Z OUT
	ADD HL DE
	JR LOOP1
OUT	LD HL RAM
LOOP2	LD A (HL)
	CP B
	JR NZ FAIL1
	INC HL
	LD A (HL)
	CP C
	JR NZ FAIL2
	INC HL
	SBC HL DE
	JR Z NEXT
	ADD HL DE
	JR LOOP2
FAIL1	DEC HL
FAIL2	DEC HL
	LD D H
	LD E L
NEXT	XOR A
	CP B
	LD A 55H
	JR Z RT
	CP B
	LD A C
	JR Z RT
	OR A
	LD A 0FFH
	JR NZ RT
*Exit Ramtest with top of RAM in DE and alternating
*00/FF in ram.
	EJECT
;Now initialise other system parameters
	LD SP,STACK
	PUSH DE
	LD HL,INITVALS
	LD DE,PARS
	LD BC PARCNT
	LDIR
	POP HL
	LD (B4) HL
	IN A,(STREG)
	BIT EXTEST A
	JR Z EXIS4
	LD A 24
	LD (EXCESS) A
EXIS4	LD A 52H	;TO GIVE TS & RS = 1
	OUT (ENREG) A
	IN A (STREG)	;To get MP, TVC~ and 40/80~
	AND 07H
	LD B A
	CP 4
	JR Z DPSLOK	;if TVC~ = 0, 40/80~ = 0 & MP = 1
	LD A,0
	LD (DPSL) A
DPSLOK	LD A B
	AND 6
	CP 4
	JR Z DEV0OK
	LD A 3		;if TVC~ = 1  or  MP = 0
	LD (DEV0) A
DEV0OK	LD A (EXROM)
	BIT 7 A
	JP Z EXROM+1	;if there is a rom at EXROM
	EI
	LD HL,(UP)
CALLHL:	JP (HL)
 
	EJECT
INITVALS	;Initial Values of O/S parameters.
PARBAS	EQU	PARS-INITVALS	;displ to calc param addr
	DI
TPON	EQU PARBAS+$
PON	EQU PARBAS+$+1
	JP PONINT
B3PRM	EQU PARBAS+$
	DEFW RAMLO
B4	EQU PARBAS+$
	DEFB 0,0
TRST8	EQU PARBAS+$
RST8	EQU PARBAS+$+1
	JP 0
DEV0	EQU PARBAS+$
	DEFB 0
 
;VIDEO
 
EXCESS	EQU PARBAS+$
	DEFB 4
TV0	EQU PARBAS+$	;FLASH CLOCK
	DEFB 0
TV2	EQU PARBAS+$	;CURSOR FLAGS
	DEFB 0
TV1	EQU PARBAS+$	;CHAR AT CURSOR
	DEFB 0
TEXM	EQU PARBAS+$
EXM	EQU PARBAS+$+1
	JP PCLRTN
DEV2	EQU PARBAS+$
	DEFB 1
SAVE2	EQU PARBAS+$	;IX save for poorly done BASIC
	DEFW 0
SAVE3	EQU PARBAS+$	;IY save
	DEFW 0
TEXMNC	EQU PARBAS+$
EXMNC	EQU PARBAS+$+1
	JP PCLRNC
PLLEN	EQU PARBAS+$
	DEFB 0
PHPOS	EQU PARBAS+$
	DEFB 0
PZLEN	EQU PARBAS+$
	DEFB 0
SAVE1	EQU PARBAS+$	;SP save for temp. power down
	DEFW 0
TRST32	EQU PARBAS+$
RST32	EQU PARBAS+$+1
	JP POSRTN
BRKBUF	EQU PARBAS+$
	DEFB 0
 
;ENABLE REGISTER
 
ENREGMAP	EQU PARBAS+$
	DEFB TVOFF+PTRDMSK+V24DMSK
		;allow clock interrupts, video off, V24
		;and printer data bits high
IOPUC	EQU PARBAS+$
	DEFB 0
UP	EQU PARBAS+$	;entry addr for user prog.
	DEFW BASIC
TRST40	EQU PARBAS+$
RST40	EQU PARBAS+$+1
	JP POSRNC
KBMODE	EQU PARBAS+$
	DEFB 0
GSPR	EQU PARBAS+$	;addr of get spc rtn
	DEFW MKSPC
RSPR	EQU PARBAS+$	;addr of return spc rtn
	DEFW RETSPC
TRST48	EQU PARBAS+$
RST48	EQU PARBAS+$+1
	JP 0
BUFLG	EQU PARBAS+$
	DEFB 0
DPSP	EQU PARBAS+$
	DEFW TPSTR
DPSL	EQU PARBAS+$
	DEFW TPSTRE-TPSTR
TINT	EQU PARBAS+$
INT	EQU PARBAS+$+1
	JP INTRPT
 
;COP
 
COPCTL	EQU PARBAS+$
	DEFB DISPCOM
COPST	EQU PARBAS+$
	DEFB 32		;i.e READY
COPBUF	EQU PARBAS+$
	DEFB 0
OUTBUFF	EQU PARBAS+$
	DEFB 20H,20H,20H,20H
	DEFB 20H,20H,20H,20H
	DEFB 20H,20H,20H,20H
	DEFB 20H,20H,20H,20H
OBFEND	EQU OUTBUFF+15
TIMBUFF	EQU PARBAS+$
	DEFW PDNTIM
CHKSUM	EQU PARBAS+$
	DEFW 0
CLACK	EQU PARBAS+$
	DEFW 0,0
CLOCK	EQU CLACK	;because it's inaccurate
 
;IOS
 
STRTAB	EQU PARBAS+$
	DEFW RAMLO
DEVTAB	EQU PARBAS+$
	DEFW PADT
TVCUR	EQU PARBAS+$
	DEFW 0
TVRAM	EQU PARBAS+$
	DEFW 0
OTHER1	EQU PARBAS+$
	DEFW 0
OTHER2	EQU PARBAS+$
	DEFW 0
IOSRAM	EQU PARBAS+$
	DEFW RAMLO
STRTOP	EQU PARBAS+$
	DEFW RAMLO
TNMI	EQU PARBAS+$
NMI	EQU PARBAS+$+1
	JP NMIRST
 
FICLKM	EQU PARBAS+$	;FR.INT. CLOCK STORE
	DEFB 0,0,0
FICLKL	EQU FICLKM+2
FICLKE	EQU FICLKM-1
 
TBRP	EQU PARBAS+$
	DEFB 2
RBRP	EQU PARBAS+$
	DEFB 2
IOPON	EQU PARBAS+$
	JP IOP1
IOPOFF	EQU PARBAS+$
	JP IOP2
DEFNF	EQU PARBAS+$
 
PARCNT	EQU PARBAS+$-PARS
 
	EJECT
*MEMORY MANAGEMENT
 
SPACE:	LD HL,(GSPR)
	CALL UPRC
	LD A,NOROOM
	RET C
	LD HL,(B3PRM)
	ADD HL,BC
	JR GSP1
 
GSPCBK:	LD HL,(RSPR)
	CALL UPRC
	OR A
	LD HL,(B3PRM)
	SBC HL,BC
GSP1:	LD (B3PRM),HL
	RET
 
UPRC:		;call the user program memory management
		;routine whose address is in HL, using IX
		;and IY from save locations and putting
		;IX and IY back after.
	PUSH IX
	PUSH IY
	CALL RESIRS
	CALL CALLHL
	CALL SAVIRS
	POP IY
	POP IX
	RET
 
SAVIRS:		;Save IX and IY
	LD (SAVE2),IX
	LD (SAVE3),IY
	RET
 
RESIRS:		;Restore IX and IY
	LD IX,(SAVE2)
	LD IY,(SAVE3)
	RET
 
	EJECT
*KEYBOARD
 
GETKEY	PUSH IX			;AFBCDEHL destroyed
	PUSH IY
	CALL IMMKEY		;CLEAR KDATA
WTLP	DI
	LD HL COPST
	BIT KDATA (HL)
	JR NZ GOTIT
	LD A (ENREGMAP)
	BIT IOPOWER A
	JR NZ WAIT1		;IF IOPOWER UP
	BIT READY (HL)		;ELSE POWERDOWN Z80
	JR Z WAITI		;IF COP NOT READY
	BIT TIMEOUT (HL)
	JR NZ WAITI		;IF TIMING OUT COP
	SET TIMEOUT (HL)	;ELSE SET UP COP TIMEOUT
	RES READY (HL)
	DEC HL
	LD (HL) TIMCOM+8	;SUPPRESS REGULAR INTRPT.
	LD HL PDNTIM
	LD (TIMBUFF) HL
WAITI	LD (SAVE1) SP		;SAVE STACK PTR.
POFF	EI
	HALT			;POWERDOWN (OR NOT)
PONINT	IM 1			;HERE ON POWERUP OR IF UNHALTED
	LD SP (SAVE1)
WAIT1	EI
	JR WTLP
 
GOTIT	POP IY
	POP IX
	RES TIMEOUT (HL)
IMMKEY	LD HL COPST		;DESTROYS HL
	DI
	BIT KDATA (HL)
	RES KDATA (HL)
	INC HL
	LD A (HL)
	EI
	SCF
	RET Z
	OR A
	RET
 
	EJECT
*INTERRUPT SERVICE ROUTINES
 
INTRPT	PUSH AF
	IN A (STREG)
	PUSH HL
	PUSH DE
	PUSH BC
	CALL INTSER
	POP BC
	POP DE
	POP HL
	POP AF
	EI
	RETI
 
 
INTSER	BIT COPINTBAR,A
	JR Z COPIS
	BIT CLKINTBAR A
ACIAIS:		;TEMPORARY
UPTIS:		;TEMPORARY
	RET NZ
FRINT	LD A CLRCLK	;FRAME INTRPT
	OUT (INTCON) A	;to clear CLK int.
	LD HL FICLKL	;to increment clock
	INC (HL)
	JR NZ CLKEND
	DEC HL
	INC (HL)
	JR NZ CLKEND
	DEC HL
	INC (HL)
CLKEND	LD HL BUFLG
	BIT 0 (HL)
	JR NZ NOVID
	LD HL TV0
	INC (HL)
	LD C (HL)
	INC HL
	BIT 4 (HL)
	RES 4 (HL)
	JR NZ NOVID
	BIT 7 (HL)
	JR Z NOVID
	BIT 6 (HL)
	JR Z NOCUR
	LD B (HL)
	INC HL
	BIT 4 C
	LD A (HL)
	JR Z SHOCHR
	LD A UNLIN
	BIT 5 B
	JR NZ CMPCHR
	LD A DOOR
CMPCHR	CP (HL)
	JR NZ SHOCHR
	LD A SPCE
SHOCHR	LD HL (TVCUR)
	LD (HL) A
NOCUR	EI
	PUSH IX
	CALL SETFRM	;TO PICK UP BC
	POP IX
	LD A C
	RLA
	LD A B
	RLA
	DI
	OUT (TVLL) A
	BIT 6 C
	JR Z LOWADD
	OUT (TVLATCH) A
LOWADD	LD A (EXCESS)
	CP 24		;JUMPS 'OUT' IF EXCESS = 24
	JR Z TVPON
	LD A 1		;TVD
	OUT (C) A
TVPON:	LD HL,ENREGMAP
	SET VIDEO,(HL)	;Turns on scan
	JR LDENREG
 
NOVID	LD HL ENREGMAP
	RES VIDEO (HL)
LDENREG:LD A (HL)
	OUT (ENREG) A
	RET
 
	EJECT
*COP INTERRUPT SERVICE
 
COPIS	EQU $
	LD C,COP
	IN A,(C)	;GET INTRPT VECTOR
	LD HL,COPCTL
	LD D,(HL)	; POINT HL AT ACK. WORD
	OUT (C),D	; AND SEND IT TO COP
	INC HL		; POINT HL AT COPSTATUS
	LD B,10H	;BRANCH ACCORDING TO BITS
	SUB B		;4-6 OF VECTOR, WILL ARRIVE
	JR C REGINT	;CODE 0XH
	SUB B
	JR C CASSERR	;CODE 1XH
	SUB B
	JR C CASSIN	;CODE 2XH
	SUB B
	JR C KBD	;CODE 3XH
	SUB B
	RET NC
		;RETURN WITH CODE >= 5XH (POWER UP INTRPT)
		;WHICH IS AN IMPOSSIBLE SITUATION
		;(NOT QUITE)
		;HERE WITH CODE 4XH (CASSOUT)
	CALL CASSVR
	LD B CODEL	;
CODLP	DJNZ CODLP	;
	LD A (HL)	;
	OUT (C) A	;put char. out to COP
	RET
	
CASSIN	RRA		;
	JR C SCHBIT-$	;bottom bit indicates
	CALL CASSVR
	LD B CIDEL	;
CIDLP	DJNZ CIDLP	;
	IN A (C)	;gets char. from COP
	LD (HL) A
	RET
 
SCHBIT	RRA		;ASSUMES CBRK = BIT 0 HERE
	RET NC
	LD A (BRKBUF)
	OR A
	RET NZ
	SET BRKOK (HL)
	XOR A
	DEFB 01H	;op-code for LD BC,nn-i.e. skip
CASSERR	EQU $
	LD A DROPOUTERR
	SET READY (HL)
	SET CERR (HL)
	INC HL
	LD (HL) A
	RET
 
CASSVR:	LD A,(ENREGMAP)
	RES VIDEO,A
	OUT (ENREG),A
	SET READY,(HL)
	INC HL
	RET
 
KBD	EQU $
	DEC HL
	LD A 80H
	OUT (C) A
	INC HL
	SET KDATA (HL)
KBDLP	CALL $8004	 ;GTKEY 
	NOP 
	NOP
	NOP
	NOP
	;IN B (C)
	;CP B
	;JR Z KBDLP
	;IN A (C)
	INC HL
	LD (HL),A
	DEC HL
	AND 3FH
	CP 18H		;* KEY
	JR NZ PREND
	BIT BRKOK (HL)
	RET Z
	RES KDATA (HL)
PREND	RES BRKOK (HL)
	RET
 
REGINT	EQU $
	AND 07H		;COPY BITS 0-2 (TIMER0,BATTLOW
	OR (HL)		;BRK,RESP) TO COPST
	LD (HL),A
	SET READY,(HL)
	DEC HL		;POINT BACK AT COPCTL
	LD (HL),NULLCOM
	LD A,D		;OLD COMMAND CODE
	AND 0F0H	;MASK OFF CONTROL BITS
	LD D,18
	INC HL	;Now HL->COPST = OUTBUFF-2
	CP DISPCOM
	JR Z URAM
	CP NULLCOM 
	JR Z PDN?
	CP TIMCOM
	JR NZ UCLACK
	LD HL,TIMBUFF-2
	LD D,6
URAM:	LD B,SYNCDEL
SYNDLP	IN A (STREG)	;was just DJNZ SYNDLP
	BIT COPINTBAR,A
	JR NZ SYNDLP
	BIT CLKINTBAR,A
	JR NZ SYNDLP
	LD B,D
OUTLP	OUTI		;WRITE 1 BYTE EVERY 20 MUSECS
	PUSH IX
	POP IX
	NOP
	NOP
	LD A,(HL)
	LD A,(HL)
	JR NZ OUTLP
UCLACK	LD B,4
	LD HL,CLACK
UCLKLP	INC (HL)
	INC HL
	RET NZ
	DJNZ UCLKLP
	RET
 
PDN?	BIT TIMER0,(HL)
	RES TIMER0,(HL)
	JR Z UCLACK
	BIT TIMEOUT,(HL)
	JR Z UCLACK
	LD A,PDNCOM
	OUT (C),A
	RES TIMEOUT,(HL)
	DEC HL
	LD (HL),DISPCOM
	LD HL POFF
	PUSH HL
	RETI
 
	EJECT
	EJECT
* NMI RESTART CODE
 
NMIRST:	LD SP,STACK
	CALL RESIRS
	LD HL,BREADY
	PUSH HL
	EI
	RETN
 
* RDKEY ROUTINE FOR XIO
 
RDKEY	PUSH HL
	PUSH DE
	PUSH BC
CSET	DEFW ZGETKEY
	DEFW ZKLOOK
	JR NC CNSET
	JR NZ CSET
	LD (HL) A
	JR CSET
CNSET	POP BC
	POP DE
	POP HL
	RET
 
* CONSTANT PI/2 ROUTINE (MATHS)
 
FPID2:	LD HL,CPID2
	JP FSTO
 
	DEFB 0		;filler
 
	ORG 0E31BH
 
*SYSTEM QUERIES
 
BRKTST	EQU $	;Tests and clears break key flag.
		;Preserves BCDEHL
		;Returns CY clear and A preserved if
		;flag clear, else returns CY set and
		;A = 0.
	LD A (BRKBUF)
	OR A
	RET NZ
	PUSH HL
	LD HL,COPST
	BIT BRKKEY,(HL)
	RES BRKKEY,(HL)
	POP HL
	RET Z
	XOR A
	SCF 
	RET
 
STKTST	LD HL -STKRAM
	ADD HL SP
	OR A
	SBC HL BC
	RET
 
	EJECT
RDNSP:		;parse routine for parameter strings
		;along with RDBYTE and RDINT
		;This routine scans the (HL) string of
		;max length C bytes for the first non-space
		;character, and returns it in A as upper case
		;if found. Zero flag set if no more chars.
	DEC HL
	INC C
RDNSP2	INC HL
	DEC C
	RET Z
	CALL HLTTCAPS
	CP ' '
	RET NZ
	JR RDNSP2
 
* SHLREG ROUTINE FOR SQRT IN MATHS
 
SHLREG:	PUSH BC
	LD B,6
SHLLP	RL (HL)
	DEC L
	DJNZ SHLLP
	POP BC
	RET
 
	ORG 0E34CH
 
TPSTR	DEFM 'L24'
TPSTRE	EQU $
 
	EJECT
*V3 CONTROL
 
IOP1	PUSH HL
	LD HL ENREGMAP
	DI
	SET IOPOWER (HL)
	LD A (HL)
	OUT (ENREG) A
	EI
	INC HL		;point at use count
	INC (HL)
	OR A		;clears CY
	POP HL
	RET
 
IOP2	LD HL IOPUC	;should preserve C-flag
	DEC (HL)
	RET NZ
	DEC HL		;point at ENREGMAP
	DI
	RES IOPOWER (HL)
	LD A (HL)
	OUT (ENREG) A
	EI
	RET
 
	EJECT
*SYNTAX
 
HLTTCAPS: LD A,(HL)
TTCAPS	CP 61H
	RET C
	CP 7BH
	RET NC
	SUB 20H
	RET
 
RDIGIT	CP 30H
	RET C
	CP 3AH
	CCF
	RET C
	SUB 30H
	RET
 
 
RDBYTE:
		;Read 8 bit positive integer into A.
		;Preserves BDE
		;Interface otherwise as for RDINT.
	PUSH DE
	CALL RDINT
	LD A,0
	SBC A,D		;set CY if already set or
	LD A,E		;if ans>255
	POP DE
	RET
 
	EJECT
RDINT:		;Read integer
		;On entry: HL-> first chr to be read
		;	C=count of chars
		;Reads 16 bit positive integer,
		;leading non-digits not allowed
		;On exit: CY clear if no errors
		;	DE=integer
		;	HL->one past last digit read
		;	C=count of chrs to go
		;	A destroyed, B preserved
		;	CY set if overflow or no integer
		;	found (HLBC pres.,ADE destroyed)
	PUSH BC
	PUSH HL
	LD DE,0
	LD B,E		;flag not yet found digit
	DEC HL
	INC C
RDILP:	INC HL		;pt at nxt char
	DEC C
	SCF
	LD A,(HL)
	CALL NZ RDIGIT	;if another char.
	JR NC RDI1	;if a digit
	DEC B
	JR NZ RDI2	;if havn't found integer
	POP AF
	POP AF		;restore B
	LD B,A
	OR A
	RET
 
RDI1:	LD B,1		;flag digit found
	PUSH HL
	LD L,A		;Multiply total so far by
	LD H,0		;10 and add in A.
	LD A,10
RDILP1:	ADD HL,DE
	JR C RDI15	;if overflow
	DEC A
	JR NZ RDILP1
	EX DE,HL
RDI15:	POP HL
	JR NC RDILP	;unless overflow
RDI2:	POP HL		;error exit
	POP BC
	RET
 
	END
                                                                                                                               